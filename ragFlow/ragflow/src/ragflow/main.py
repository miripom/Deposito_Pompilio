"""Main entrypoint for the Intelligent Search Flow application.

Defines the state and flow to route user questions to the appropriate
specialized crews (math, tutorial, medical RAG, or web search) and prints
formatted results.
"""

from pydantic import BaseModel
from crewai import Crew  # pylint: disable=import-error
from crewai.flow.flow import Flow, listen, router, start  # pylint: disable=import-error

from ragflow.crews.classifier_crew.classifier_crew import ClassifierCrew
from ragflow.crews.math_crew.math_crew import MathCrew
from ragflow.crews.rag_crew.rag_crew import RagCrew
from ragflow.crews.search_crew.search_crew import SearchCrew
from ragflow.crews.tutorial_crew.tutorial_crew import TutorialCrew

class IntelligentSearchState(BaseModel):
    """State for the Intelligent Search Flow.

    Attributes:
        user_query (str): The user's input question.
        is_math (str): "MATH" or "NON-MATH" indicating if the question is mathematical.
        math_type (str): "CALCULATION" or "EXPLANATION" for math questions.
        domain_classification (str): "medical" or "general" for non-math questions.
        search_type (str): The selected search type ("math_calc", "math_tutorial", "rag", "web").
        summary (str): The summary or answer generated by the system.
        result (str): The final result message.
    """
    user_query: str = ""
    is_math: str = ""  # "MATH" o "NON-MATH"
    math_type: str = ""  # "CALCULATION" o "EXPLANATION"
    domain_classification: str = ""  # "medical" o "general" (solo per non-math)
    search_type: str = ""  # "math_calc", "math_tutorial", "rag", "web"
    summary: str = ""
    result: str = ""

class IntelligentSearchFlow(Flow[IntelligentSearchState]):
    """Main flow for intelligent question routing and answering."""

    @start()
    def get_user_question(self):
        """Prompt the user for a question and store it in the state.

        Returns:
            str: The user's question.
        """
        print("\nğŸ¤– ASSISTENTE RICERCA INTELLIGENTE")
        print("Fai una domanda e il sistema sceglierÃ  automaticamente la fonte migliore:")
        print("ğŸ§® Calcoli matematici â†’ Calcolatore matematico")
        print("ğŸ“– Spiegazioni matematiche â†’ Tutorial team")
        print("ğŸ¥ Domande mediche â†’ Database locale (RAG)")
        print("ğŸŒ Domande generali â†’ Ricerca web")
        print()

        query = input("â“ Inserisci la tua domanda: ").strip()
        if not query:
            query = "Spiega come risolvere le equazioni di secondo grado"
            print(f"â¡ï¸ Domanda di esempio: {query}")

        self.state.user_query = query
        return query

    @listen(get_user_question)
    def detect_math_question(self, query: str):
        """Detect if the user's question is mathematical.

        Args:
            query (str): The user's question.

        Returns:
            str: "MATH" if the question is mathematical, otherwise "NON-MATH".
        """
        print("\nğŸ¯ LIVELLO 1: Verifico se Ã¨ una domanda matematica...")

        # Usa ClassifierCrew con task specifico per math detection
        classifier_crew = ClassifierCrew()

        # Esegui SOLO il task di math detection usando l'agent math_detector
        math_detector_agent = classifier_crew.math_detector()
        detect_task = classifier_crew.detect_math_task()
        detect_task.agent = math_detector_agent

        # Kickoff solo il task di math detection
        temp_crew = Crew(
            agents=[math_detector_agent],
            tasks=[detect_task]
        )

        classification_result = temp_crew.kickoff(inputs={"question": query})
        math_classification = str(classification_result).strip().upper()

        # Pulisci la risposta per assicurarsi che sia solo MATH o NON-MATH
        if "MATH" in math_classification and "NON" not in math_classification:
            self.state.is_math = "MATH"
            print("ğŸ§® Domanda MATEMATICA rilevata â†’ Analizzo il tipo...")
        else:
            self.state.is_math = "NON-MATH"
            print("ğŸ“ Domanda NON-MATEMATICA â†’ Procedo con classificazione dominio...")

        return self.state.is_math

    @router(detect_math_question)
    def route_after_math_detection(self):
        """Route to the next step based on math detection.

        Returns:
            str: The next step ("classify_math_type" or "classify_nonmath_domain").
        """
        if self.state.is_math == "MATH":
            return "classify_math_type"
        return "classify_nonmath_domain"

    @listen("classify_math_type")
    def determine_math_type(self):
        """Determine if the math question is a calculation or an explanation.

        Returns:
            str: "CALCULATION" or "EXPLANATION".
        """
        print("\nğŸ¯ LIVELLO 2: Determino se Ã¨ un calcolo o una richiesta di spiegazione...")

        query_upper = self.state.user_query.upper()

        # Keywords che indicano richiesta di spiegazione/tutorial
        explanation_keywords = [
            "SPIEGA", "SPIEGAMI", "PARLAMI", "COME SI", "COME FUNZIONA",
            "COS'Ãˆ", "COSA SONO", "DIMMI", "INSEGNA", "TUTORIAL",
            "PERCHÃ‰", "QUANDO", "METODO", "TEORIA", "CONCETTO",
            "DEFINIZIONE", "PROPRIETÃ€", "REGOLA", "FORMULA"
        ]

        # Keywords che indicano calcolo puro
        calculation_keywords = [
            "CALCOLA", "RISOLVI", "TROVA", "QUANTO FA", "=", 
            "RISULTATO", "VALORE", "DETERMINA IL VALORE"
        ]

        # Controlla se Ã¨ una richiesta di spiegazione
        is_explanation = any(keyword in query_upper for keyword in explanation_keywords)

        # Controlla se Ã¨ un calcolo esplicito
        is_calculation = any(keyword in query_upper for keyword in calculation_keywords)

        # Se contiene operatori matematici senza richiesta di spiegazione, Ã¨ un calcolo
        has_math_operators = any(
            op in self.state.user_query for op in ['+', '-', '*', '/', '=', '^', 'Â²', 'Â³']
        )

        if is_explanation or (
            not is_calculation and not has_math_operators and len(self.state.user_query.split()) > 3
        ):
            self.state.math_type = "EXPLANATION"
            self.state.search_type = "math_tutorial"
            print("ğŸ“– Richiesta di SPIEGAZIONE matematica â†’ Uso Tutorial Team")
        else:
            self.state.math_type = "CALCULATION"
            self.state.search_type = "math_calc"
            print("ğŸ§® Richiesta di CALCOLO â†’ Uso Math Solver")

        return self.state.math_type

    @router(determine_math_type)
    def route_math_type(self):
        """Route to calculation or tutorial based on math type.

        Returns:
            str: The next step ("perform_math_calculation" or "create_math_tutorial").
        """
        if self.state.math_type == "CALCULATION":
            return "perform_math_calculation"
        return "create_math_tutorial"

    # ========== PERCORSO TUTORIAL MATEMATICO ==========
    @listen("create_math_tutorial")
    def generate_math_tutorial(self):
        """Generate a detailed math tutorial using the TutorialCrew.

        Returns:
            str: The generated tutorial summary.
        """
        print("\nğŸ“– Creo un tutorial matematico dettagliato...")
        print("ğŸ‘¨â€ğŸ« Il manager sta organizzando il contenuto didattico...")

        tutorial_crew = TutorialCrew().crew()
        result = tutorial_crew.kickoff(inputs={"topic": self.state.user_query})
        self.state.summary = str(result)
        return self.state.summary

    @listen(generate_math_tutorial)
    def display_math_tutorial_results(self, summary: str):
        """Display the results of the math tutorial.

        Args:
            summary (str): The tutorial summary.

        Returns:
            str: Success message.
        """
        print("\n" + "="*60)
        print("ğŸ“– TUTORIAL MATEMATICO")
        print("="*60)
        print(f"â“ Argomento: {self.state.user_query}")
        print("ğŸ‘¨â€ğŸ« Fonte: Tutorial Team Matematico")
        print("-"*60)
        print(f"ğŸ“š Tutorial:\n{summary}")
        print("="*60)

        self.state.result = "Tutorial matematico creato con successo!"
        return self.state.result

    # ========== PERCORSO CALCOLO MATEMATICO ==========
    @listen("perform_math_calculation")
    def calculate_with_math(self):
        """Perform a mathematical calculation using the MathCrew.

        Returns:
            str: The calculation result summary.
        """
        print("\nğŸ§® Eseguo il calcolo matematico...")

        math_crew = MathCrew().crew()
        result = math_crew.kickoff(inputs={"question": self.state.user_query})
        self.state.summary = str(result)
        return self.state.summary

    @listen(calculate_with_math)
    def display_math_results(self, summary: str):
        """Display the results of the mathematical calculation.

        Args:
            summary (str): The calculation summary.

        Returns:
            str: Success message.
        """
        print("\n" + "="*60)
        print("ğŸ§® RISULTATO MATEMATICO")
        print("="*60)
        print(f"â“ Problema: {self.state.user_query}")
        print("âš¡ Fonte: Calcolatore matematico")
        print("-"*60)
        print(f"ğŸ“Š Soluzione:\n{summary}")
        print("="*60)

        self.state.result = "Calcolo matematico completato!"
        return self.state.result

    @listen("classify_nonmath_domain")
    def classify_domain_for_nonmath(self):
        """Classify the domain of a non-math question (medical or general).

        Returns:
            str: The selected search type ("rag" or "web").
        """
        print("\nğŸ¯ LIVELLO 2: Classifico il dominio (Medical vs General)...")

        # Usa ClassifierCrew con task specifico per domain classification
        classifier_crew = ClassifierCrew()

        # Esegui SOLO il task di domain classification usando l'agent domain_classifier
        domain_classifier_agent = classifier_crew.domain_classifier()
        classify_task = classifier_crew.classify_nonmath_domain_task()
        classify_task.agent = domain_classifier_agent

        # Kickoff solo il task di domain classification
        temp_crew = Crew(
            agents=[domain_classifier_agent],
            tasks=[classify_task]
        )

        classification_result = temp_crew.kickoff(inputs={"question": self.state.user_query})
        domain_classification = str(classification_result).strip().upper()

        if "MEDICAL" in domain_classification:
            self.state.search_type = "rag"
            self.state.domain_classification = "medical"
            print("ğŸ¥ Domanda MEDICA rilevata â†’ Uso database medico locale")
        else:
            self.state.search_type = "web"
            self.state.domain_classification = "general"
            print("ğŸŒ Domanda GENERALE rilevata â†’ Uso ricerca web")

        return self.state.search_type

    @router(classify_domain_for_nonmath)
    def route_after_domain_classification(self):
        """Route to RAG or web search based on domain classification.

        Returns:
            str: The next step ("perform_rag_search" or "perform_web_search").
        """
        if self.state.search_type == "rag":
            return "perform_rag_search"
        return "perform_web_search"

    # ========== PERCORSO RAG MEDICO ==========
    @listen("perform_rag_search")
    def search_with_rag(self):
        """Search the local medical database using RagCrew.

        Returns:
            str: The RAG search summary.
        """
        print("\nğŸ“š Cerco nel database medico locale...")

        rag_crew = RagCrew().crew()
        result = rag_crew.kickoff(inputs={"question": self.state.user_query})
        self.state.summary = str(result)
        return self.state.summary

    @listen(search_with_rag)
    def display_rag_results(self, summary: str):
        """Display the results from the medical database.

        Args:
            summary (str): The RAG search summary.

        Returns:
            str: Success message.
        """
        print("\n" + "="*60)
        print("ğŸ“‹ RISPOSTA DAL DATABASE MEDICO")
        print("="*60)
        print(f"â“ Domanda: {self.state.user_query}")
        print("ğŸ¥ Fonte: Database medico locale")
        print("-"*60)
        print(f"ğŸ“š Risposta:\n{summary}")
        print("="*60)

        self.state.result = "Ricerca medica completata!"
        return self.state.result

    # ========== PERCORSO RICERCA WEB ==========
    @listen("perform_web_search")
    def search_with_web(self):
        """Search the web using SearchCrew.

        Returns:
            str: The web search summary.
        """
        print("\nğŸŒ Cerco su internet con DuckDuckGo...")

        search_crew = SearchCrew().crew()
        result = search_crew.kickoff(inputs={"query": self.state.user_query})
        self.state.summary = str(result)
        return self.state.summary

    @listen(search_with_web)
    def display_web_results(self, summary: str):
        """Display the results from the web search.

        Args:
            summary (str): The web search summary.

        Returns:
            str: Success message.
        """
        print("\n" + "="*60)
        print("ğŸ“‹ RISULTATI DALLA RICERCA WEB")
        print("="*60)
        print(f"â“ Domanda: {self.state.user_query}")
        print("ğŸŒ Fonte: Ricerca internet")
        print("-"*60)
        print(f"ğŸ“„ Risultati:\n{summary}")
        print("="*60)

        self.state.result = "Ricerca web completata!"
        return self.state.result


def kickoff():
    """Kick off the IntelligentSearchFlow."""
    IntelligentSearchFlow().kickoff()

def plot():
    """Plot the flow diagram for IntelligentSearchFlow."""
    flow = IntelligentSearchFlow()
    flow.plot("intelligent_search_flow_plot")

if __name__ == "__main__":
    kickoff()
